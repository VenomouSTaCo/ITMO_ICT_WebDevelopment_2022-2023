{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 2022 \u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u0435 \u0440\u0430\u0431\u043e\u0442\u044b \u041a\u043e\u043d\u0435\u0432\u0430 \u0410\u043d\u0442\u043e\u043d\u0430 K33402","title":"\u0417\u043d\u0430\u043a\u043e\u043c\u0441\u0442\u0432\u043e"},{"location":"#web-2022","text":"","title":"Web-\u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 2022"},{"location":"#k33402","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u044b\u0435 \u0440\u0430\u0431\u043e\u0442\u044b \u041a\u043e\u043d\u0435\u0432\u0430 \u0410\u043d\u0442\u043e\u043d\u0430 K33402"},{"location":"LW_1/","text":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161 \u0417\u0430\u0434\u0430\u0447\u0430 \u21161 server.py import socket sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . bind (( \"127.0.0.1\" , 8071 )) sock . listen ( 5 ) client_socket , addr = sock . accept () print ( client_socket . recv ( 1024 ) . decode ( \"utf-8\" )) client_socket . send ( b \"Hello, client\" ) sock . close () client.py import socket sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( \"127.0.0.1\" , 8071 )) sock . send ( b \"Hello, server\" ) print ( sock . recv ( 1024 ) . decode ( \"utf-8\" )) sock . close () \u0417\u0430\u0434\u0430\u0447\u0430 \u21162 server.py import math import socket sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . bind (( \"127.0.0.1\" , 8091 )) sock . listen ( 10 ) client_socket , addr = sock . accept () client_socket . send ( b \"Hello, client \\n Please enter the coefficients a, b, c of your equation like ax^2+bx+c=0\" ) coefs = client_socket . recv ( 1024 ) . decode ( \"utf-8\" ) ''' https://younglinux.info/python/task/quadratic ''' a = float ( coefs [ 0 ]) b = float ( coefs [ 2 ]) c = float ( coefs [ 4 ]) discr = b ** 2 - 4 * a * c if discr < 0 : msg = \"No real roots\" elif discr == 0 : x = - b / ( 2 * a ) msg = \"x = %.2f \" % x else : x1 = ( - b + math . sqrt ( discr )) / ( 2 * a ) x2 = ( - b - math . sqrt ( discr )) / ( 2 * a ) msg = \"x1 = %.2f \\n x2 = %.2f \" % ( x1 , x2 ) client_socket . send ( msg . encode ( \"utf-8\" )) sock . close () client.py import socket sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( \"127.0.0.1\" , 8091 )) print ( sock . recv ( 1024 ) . decode ( \"utf-8\" )) coefs = input ( \"Enter a, b, c divided by space: \" ) . encode ( \"utf-8\" ) sock . send ( coefs ) print ( sock . recv ( 1024 ) . decode ( \"utf-8\" )) sock . close () \u0417\u0430\u0434\u0430\u0447\u0430 \u21163 server.py import socket conn = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) conn . bind (( '127.0.0.1' , 8901 )) conn . listen ( 10 ) while True : try : client_socket , addr = conn . accept () client_socket . recv ( 1024 ) response_type = \"HTTP/1.0 200 OK \\n \" headers = \"Content-Type: text/html \\n\\n \" f = open ( \"index.html\" , \"r\" ) body = f . read () res = response_type + headers + body client_socket . send ( res . encode ( \"utf-8\" )) f . close () client_socket . close () except KeyboardInterrupt : conn . close () break index.html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < title > Main </ title > </ head > < body > < h1 > Hello, client </ h1 > </ body > </ html > \u0417\u0430\u0434\u0430\u0447\u0430 \u21164 server.py import socket conn = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) conn . bind (( '127.0.0.1' , 8902 )) clients = [] while True : try : data , client_address = conn . recvfrom ( 1024 ) if client_address not in clients : clients . append ( client_address ) for client in clients : if client != client_address : conn . sendto ( data , client ) except KeyboardInterrupt : conn . close () break client.py import socket import threading conn = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) conn . connect (( '127.0.0.1' , 8902 )) def messages (): while True : data = conn . recv ( 2048 ) print ( data . decode ( \"utf-8\" )) def chat (): name = input ( \"Enter your name: \" ) print ( f ' { name } , say hello to the chat' ) conn . sendall ( bytes ( f \" { name } joined\" , \"utf-8\" )) while True : conn . sendto ( bytes ( f \" { name } : { input () } \" , \"utf-8\" ), ( '127.0.0.1' , 8902 )) thread1 , thread2 = threading . Thread ( target = messages ), threading . Thread ( target = chat ) thread1 . start (), thread2 . start () \u0417\u0430\u0434\u0430\u0447\u0430 \u21165 server.py import socket import sys class MyHTTPServer : # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0441\u0435\u0440\u0432\u0435\u0440\u0430 def __init__ ( self , host , port , name ): self . _host = host self . _port = port self . _server_name = name # 1. \u0417\u0430\u043f\u0443\u0441\u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u043d\u0430 \u0441\u043e\u043a\u0435\u0442\u0435, \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u044f\u0449\u0438\u0445 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0439 def serve_forever ( self ): serv_sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM , proto = 0 ) try : serv_sock . bind (( self . _host , self . _port )) serv_sock . listen () while True : client , addr = serv_sock . accept () self . serve_client ( client ) finally : serv_sock . close () # 2. \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u043e\u0433\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f def serve_client ( self , client ): try : method , url , version , params , headers = self . parse_request ( client ) self . handle_request ( method , url , headers , client , params ) except ConnectionResetError : client = None if client : client . close () # 3. \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u0430 http+\u0437\u0430\u043f\u0440\u043e\u0441\u0430.\u041f\u0435\u0440\u0432\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443 \u043d\u0443\u0436\u043d\u043e \u0440\u0430\u0437\u0431\u0438\u0442\u044c \u043d\u0430 3 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 (\u043c\u0435\u0442\u043e\u0434 + url + \u0432\u0435\u0440\u0441\u0438\u044f \u043f\u0440\u043e\u0442\u043e\u043a\u043e\u043b\u0430). URL \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0440\u0430\u0437\u0431\u0438\u0442\u044c \u043d\u0430 \u0430\u0434\u0440\u0435\u0441 \u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b def parse_request ( self , client ): rfile = client . makefile ( 'rb' ) method , url , version , params = None , None , None , None for line in rfile : words = line . decode ( 'utf-8' , errors = 'ignore' ) . split () if len ( words ) != 3 : raise Exception ( 'Malformed request line' ) method , url , version = words # \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0435\u0441\u0442\u044c \u043b\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b if \"?\" in url : url , params = url . split ( '?' ) break headers = self . parse_headers ( rfile ) return method , url , version , params , headers # 4. \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 headers. \u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043f\u0440\u043e\u0447\u0438\u0442\u0430\u0442\u044c \u0432\u0441\u0435 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u0438 \u043f\u043e\u0441\u043b\u0435 \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438 \u0434\u043e \u043f\u043e\u044f\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u0443\u0441\u0442\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438 \u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0438\u0445 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432. @staticmethod def parse_headers ( rfile ): headers = [] for line in rfile : if line in ( b ' \\r\\n ' , b ' \\n ' , b '' ): break headers . append ( line ) return headers # 5. \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 url \u0432 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0438 \u0441 \u043d\u0443\u0436\u043d\u044b\u043c \u043c\u0435\u0442\u043e\u0434\u043e\u043c. \u0412 \u0441\u043b\u0443\u0447\u0430\u0435 \u0434\u0430\u043d\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b, \u043d\u0443\u0436\u043d\u043e \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u043d\u0430\u0431\u043e\u0440 \u0443\u0441\u043b\u043e\u0432\u0438\u0439, # \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 GET \u0438\u043b\u0438 POST \u0437\u0430\u043f\u0440\u043e\u0441. GET \u0437\u0430\u043f\u0440\u043e\u0441 \u0434\u043e\u043b\u0436\u0435\u043d \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435. POST \u0437\u0430\u043f\u0440\u043e\u0441 \u0434\u043e\u043b\u0436\u0435\u043d \u0437\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0435\u0440\u0435\u0434\u0430\u043d\u043d\u044b\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432. def handle_request ( self , method , url , headers , client , params ): if url == \"/\" : if method == \"GET\" : pass if method == \"POST\" and params is not None : data = params . split ( '&' ) discipline . append ( data [ 0 ] . split ( '=' )[ 1 ]) mark . append ( data [ 1 ] . split ( '=' )[ 1 ]) self . send_response ( client ) return # 6. \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u043e\u0442\u0432\u0435\u0442\u0430. \u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0432 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 status line \u0432\u0438\u0434\u0430 HTTP/1.1 <status_code> <reason>. # \u0417\u0430\u0442\u0435\u043c, \u043f\u043e\u0441\u0442\u0440\u043e\u0447\u043d\u043e \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u0438 \u0438 \u043f\u0443\u0441\u0442\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443, \u043e\u0431\u043e\u0437\u043d\u0430\u0447\u0430\u044e\u0449\u0443\u044e \u043a\u043e\u043d\u0435\u0446 \u0441\u0435\u043a\u0446\u0438\u0438 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u043e\u0432. @staticmethod def send_response ( client ): resp = \"HTTP/1.1 200 OK \\n\\n \" with open ( 'index.html' , 'r' ) as f : for line in f : if '<div id=\"on__server\"> \\n ' == line : for i in range ( len ( discipline )): resp += '<p id=\"on__server\"> Discipline: ' + discipline [ i ] + ', Mark: ' + mark [ i ] + '</p>' resp += line client . send ( resp . encode ( 'UTF-8' )) if __name__ == '__main__' : host = 'localhost' port = 9095 name = 'example' serv = MyHTTPServer ( host , port , name ) discipline = [] mark = [] try : serv . serve_forever () except KeyboardInterrupt : pass index.html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < title > Journal </ title > < style > body { margin : auto ; text-align : center } . input__container { margin-bottom : 20 px } </ style > </ head > < body > < p > Hello, client </ p > < form name = \"input__form\" id = \"form\" method = \"post\" accept-charset = \"UTF-8\" > < div class = \"input__container\" > < label for = \"Discipline\" ></ label >< input id = \"Discipline\" class = \"discipline__input\" name = \"Discipline\" required type = \"text\" placeholder = \"Discipline\" > </ div > < div class = \"input__container\" > < label for = \"Mark\" ></ label >< input id = \"Mark\" class = \"mark__input\" name = \"Mark\" required type = \"number\" placeholder = \"Mark\" value = \"value\" > </ div > < div class = \"button__container\" ></ div > </ form > < div id = \"on__server\" > </ div > < script > function submit () { let discipline = document . querySelector ( '.discipline__input' ); let mark = document . querySelector ( '.mark__input' ); fetch ( `/?Discipline= ${ discipline . value } &Mark= ${ mark . value } ` , { method : 'POST' }) } let button = document . createElement ( 'button' ); button . onclick = ( submit ) button . innerHTML = 'Submit' document . querySelector ( '.button__container' ). append ( button ); </ script > </ body > </ html >","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161"},{"location":"LW_1/#no1","text":"","title":"\u041b\u0430\u0431\u043e\u0440\u0430\u0442\u043e\u0440\u043d\u0430\u044f \u0440\u0430\u0431\u043e\u0442\u0430 \u21161"},{"location":"LW_1/#no1_1","text":"server.py import socket sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . bind (( \"127.0.0.1\" , 8071 )) sock . listen ( 5 ) client_socket , addr = sock . accept () print ( client_socket . recv ( 1024 ) . decode ( \"utf-8\" )) client_socket . send ( b \"Hello, client\" ) sock . close () client.py import socket sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( \"127.0.0.1\" , 8071 )) sock . send ( b \"Hello, server\" ) print ( sock . recv ( 1024 ) . decode ( \"utf-8\" )) sock . close ()","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21161"},{"location":"LW_1/#no2","text":"server.py import math import socket sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . bind (( \"127.0.0.1\" , 8091 )) sock . listen ( 10 ) client_socket , addr = sock . accept () client_socket . send ( b \"Hello, client \\n Please enter the coefficients a, b, c of your equation like ax^2+bx+c=0\" ) coefs = client_socket . recv ( 1024 ) . decode ( \"utf-8\" ) ''' https://younglinux.info/python/task/quadratic ''' a = float ( coefs [ 0 ]) b = float ( coefs [ 2 ]) c = float ( coefs [ 4 ]) discr = b ** 2 - 4 * a * c if discr < 0 : msg = \"No real roots\" elif discr == 0 : x = - b / ( 2 * a ) msg = \"x = %.2f \" % x else : x1 = ( - b + math . sqrt ( discr )) / ( 2 * a ) x2 = ( - b - math . sqrt ( discr )) / ( 2 * a ) msg = \"x1 = %.2f \\n x2 = %.2f \" % ( x1 , x2 ) client_socket . send ( msg . encode ( \"utf-8\" )) sock . close () client.py import socket sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) sock . connect (( \"127.0.0.1\" , 8091 )) print ( sock . recv ( 1024 ) . decode ( \"utf-8\" )) coefs = input ( \"Enter a, b, c divided by space: \" ) . encode ( \"utf-8\" ) sock . send ( coefs ) print ( sock . recv ( 1024 ) . decode ( \"utf-8\" )) sock . close ()","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21162"},{"location":"LW_1/#no3","text":"server.py import socket conn = socket . socket ( socket . AF_INET , socket . SOCK_STREAM ) conn . bind (( '127.0.0.1' , 8901 )) conn . listen ( 10 ) while True : try : client_socket , addr = conn . accept () client_socket . recv ( 1024 ) response_type = \"HTTP/1.0 200 OK \\n \" headers = \"Content-Type: text/html \\n\\n \" f = open ( \"index.html\" , \"r\" ) body = f . read () res = response_type + headers + body client_socket . send ( res . encode ( \"utf-8\" )) f . close () client_socket . close () except KeyboardInterrupt : conn . close () break index.html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < title > Main </ title > </ head > < body > < h1 > Hello, client </ h1 > </ body > </ html >","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21163"},{"location":"LW_1/#no4","text":"server.py import socket conn = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) conn . bind (( '127.0.0.1' , 8902 )) clients = [] while True : try : data , client_address = conn . recvfrom ( 1024 ) if client_address not in clients : clients . append ( client_address ) for client in clients : if client != client_address : conn . sendto ( data , client ) except KeyboardInterrupt : conn . close () break client.py import socket import threading conn = socket . socket ( socket . AF_INET , socket . SOCK_DGRAM ) conn . connect (( '127.0.0.1' , 8902 )) def messages (): while True : data = conn . recv ( 2048 ) print ( data . decode ( \"utf-8\" )) def chat (): name = input ( \"Enter your name: \" ) print ( f ' { name } , say hello to the chat' ) conn . sendall ( bytes ( f \" { name } joined\" , \"utf-8\" )) while True : conn . sendto ( bytes ( f \" { name } : { input () } \" , \"utf-8\" ), ( '127.0.0.1' , 8902 )) thread1 , thread2 = threading . Thread ( target = messages ), threading . Thread ( target = chat ) thread1 . start (), thread2 . start ()","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21164"},{"location":"LW_1/#no5","text":"server.py import socket import sys class MyHTTPServer : # \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0441\u0435\u0440\u0432\u0435\u0440\u0430 def __init__ ( self , host , port , name ): self . _host = host self . _port = port self . _server_name = name # 1. \u0417\u0430\u043f\u0443\u0441\u043a \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u043d\u0430 \u0441\u043e\u043a\u0435\u0442\u0435, \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0432\u0445\u043e\u0434\u044f\u0449\u0438\u0445 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0439 def serve_forever ( self ): serv_sock = socket . socket ( socket . AF_INET , socket . SOCK_STREAM , proto = 0 ) try : serv_sock . bind (( self . _host , self . _port )) serv_sock . listen () while True : client , addr = serv_sock . accept () self . serve_client ( client ) finally : serv_sock . close () # 2. \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u043a\u043b\u0438\u0435\u043d\u0442\u0441\u043a\u043e\u0433\u043e \u043f\u043e\u0434\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f def serve_client ( self , client ): try : method , url , version , params , headers = self . parse_request ( client ) self . handle_request ( method , url , headers , client , params ) except ConnectionResetError : client = None if client : client . close () # 3. \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u0430 http+\u0437\u0430\u043f\u0440\u043e\u0441\u0430.\u041f\u0435\u0440\u0432\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443 \u043d\u0443\u0436\u043d\u043e \u0440\u0430\u0437\u0431\u0438\u0442\u044c \u043d\u0430 3 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 (\u043c\u0435\u0442\u043e\u0434 + url + \u0432\u0435\u0440\u0441\u0438\u044f \u043f\u0440\u043e\u0442\u043e\u043a\u043e\u043b\u0430). URL \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0440\u0430\u0437\u0431\u0438\u0442\u044c \u043d\u0430 \u0430\u0434\u0440\u0435\u0441 \u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b def parse_request ( self , client ): rfile = client . makefile ( 'rb' ) method , url , version , params = None , None , None , None for line in rfile : words = line . decode ( 'utf-8' , errors = 'ignore' ) . split () if len ( words ) != 3 : raise Exception ( 'Malformed request line' ) method , url , version = words # \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u0435\u0441\u0442\u044c \u043b\u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b if \"?\" in url : url , params = url . split ( '?' ) break headers = self . parse_headers ( rfile ) return method , url , version , params , headers # 4. \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 headers. \u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u043f\u0440\u043e\u0447\u0438\u0442\u0430\u0442\u044c \u0432\u0441\u0435 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u0438 \u043f\u043e\u0441\u043b\u0435 \u043f\u0435\u0440\u0432\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438 \u0434\u043e \u043f\u043e\u044f\u0432\u043b\u0435\u043d\u0438\u044f \u043f\u0443\u0441\u0442\u043e\u0439 \u0441\u0442\u0440\u043e\u043a\u0438 \u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0438\u0445 \u0432 \u043c\u0430\u0441\u0441\u0438\u0432. @staticmethod def parse_headers ( rfile ): headers = [] for line in rfile : if line in ( b ' \\r\\n ' , b ' \\n ' , b '' ): break headers . append ( line ) return headers # 5. \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 url \u0432 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0438 \u0441 \u043d\u0443\u0436\u043d\u044b\u043c \u043c\u0435\u0442\u043e\u0434\u043e\u043c. \u0412 \u0441\u043b\u0443\u0447\u0430\u0435 \u0434\u0430\u043d\u043d\u043e\u0439 \u0440\u0430\u0431\u043e\u0442\u044b, \u043d\u0443\u0436\u043d\u043e \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0437\u0434\u0430\u0442\u044c \u043d\u0430\u0431\u043e\u0440 \u0443\u0441\u043b\u043e\u0432\u0438\u0439, # \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 GET \u0438\u043b\u0438 POST \u0437\u0430\u043f\u0440\u043e\u0441. GET \u0437\u0430\u043f\u0440\u043e\u0441 \u0434\u043e\u043b\u0436\u0435\u043d \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435. POST \u0437\u0430\u043f\u0440\u043e\u0441 \u0434\u043e\u043b\u0436\u0435\u043d \u0437\u0430\u043f\u0438\u0441\u044b\u0432\u0430\u0442\u044c \u0434\u0430\u043d\u043d\u044b\u0435 \u043d\u0430 \u043e\u0441\u043d\u043e\u0432\u0435 \u043f\u0435\u0440\u0435\u0434\u0430\u043d\u043d\u044b\u0445 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u043e\u0432. def handle_request ( self , method , url , headers , client , params ): if url == \"/\" : if method == \"GET\" : pass if method == \"POST\" and params is not None : data = params . split ( '&' ) discipline . append ( data [ 0 ] . split ( '=' )[ 1 ]) mark . append ( data [ 1 ] . split ( '=' )[ 1 ]) self . send_response ( client ) return # 6. \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438 \u043e\u0442\u0432\u0435\u0442\u0430. \u041d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0432 \u0441\u043e\u0435\u0434\u0438\u043d\u0435\u043d\u0438\u0435 status line \u0432\u0438\u0434\u0430 HTTP/1.1 <status_code> <reason>. # \u0417\u0430\u0442\u0435\u043c, \u043f\u043e\u0441\u0442\u0440\u043e\u0447\u043d\u043e \u0437\u0430\u043f\u0438\u0441\u0430\u0442\u044c \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u0438 \u0438 \u043f\u0443\u0441\u0442\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443, \u043e\u0431\u043e\u0437\u043d\u0430\u0447\u0430\u044e\u0449\u0443\u044e \u043a\u043e\u043d\u0435\u0446 \u0441\u0435\u043a\u0446\u0438\u0438 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043a\u043e\u0432. @staticmethod def send_response ( client ): resp = \"HTTP/1.1 200 OK \\n\\n \" with open ( 'index.html' , 'r' ) as f : for line in f : if '<div id=\"on__server\"> \\n ' == line : for i in range ( len ( discipline )): resp += '<p id=\"on__server\"> Discipline: ' + discipline [ i ] + ', Mark: ' + mark [ i ] + '</p>' resp += line client . send ( resp . encode ( 'UTF-8' )) if __name__ == '__main__' : host = 'localhost' port = 9095 name = 'example' serv = MyHTTPServer ( host , port , name ) discipline = [] mark = [] try : serv . serve_forever () except KeyboardInterrupt : pass index.html <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < title > Journal </ title > < style > body { margin : auto ; text-align : center } . input__container { margin-bottom : 20 px } </ style > </ head > < body > < p > Hello, client </ p > < form name = \"input__form\" id = \"form\" method = \"post\" accept-charset = \"UTF-8\" > < div class = \"input__container\" > < label for = \"Discipline\" ></ label >< input id = \"Discipline\" class = \"discipline__input\" name = \"Discipline\" required type = \"text\" placeholder = \"Discipline\" > </ div > < div class = \"input__container\" > < label for = \"Mark\" ></ label >< input id = \"Mark\" class = \"mark__input\" name = \"Mark\" required type = \"number\" placeholder = \"Mark\" value = \"value\" > </ div > < div class = \"button__container\" ></ div > </ form > < div id = \"on__server\" > </ div > < script > function submit () { let discipline = document . querySelector ( '.discipline__input' ); let mark = document . querySelector ( '.mark__input' ); fetch ( `/?Discipline= ${ discipline . value } &Mark= ${ mark . value } ` , { method : 'POST' }) } let button = document . createElement ( 'button' ); button . onclick = ( submit ) button . innerHTML = 'Submit' document . querySelector ( '.button__container' ). append ( button ); </ script > </ body > </ html >","title":"\u0417\u0430\u0434\u0430\u0447\u0430 \u21165"}]}